{"code":"Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar available_collection_1 = require(\"/both/collections/available.collection\");\r\nvar email_1 = require(\"meteor/email\");\r\nvar check_1 = require(\"meteor/check\");\r\nvar meteor_1 = require(\"meteor/meteor\");\r\nfunction getContactEmail(user) {\r\n    if (user.emails && user.emails.length) {\r\n        return user.emails[0].address;\r\n    }\r\n    return null;\r\n}\r\nmeteor_1.Meteor.methods({\r\n    invite: function (availableModelId, userId) {\r\n        check_1.check(availableModelId, String);\r\n        check_1.check(userId, String);\r\n        var availableModel = available_collection_1.Available.collection.findOne(availableModelId);\r\n        if (!availableModel) {\r\n            throw new meteor_1.Meteor.Error('404', 'No such item available!');\r\n        }\r\n        if (availableModel.public) {\r\n            throw new meteor_1.Meteor.Error('403', 'Need Permissions!');\r\n        }\r\n        if (userId !== availableModel.owner && (availableModel.invited || []).indexOf(userId) == -1) {\r\n            available_collection_1.Available.collection.update(availableModelId, { $addToSet: { invited: userId } });\r\n            var from = getContactEmail(meteor_1.Meteor.users.findOne(this.userId)), to = getContactEmail(meteor_1.Meteor.users.findOne(userId));\r\n            if (meteor_1.Meteor.isServer && to) {\r\n                email_1.Email.send({\r\n                    from: 'team@canikickit.tv',\r\n                    to: to,\r\n                    replyTo: from || undefined,\r\n                    subject: 'Available:' + availableModel.name,\r\n                    text: \"Hello, I just wnated you to know \" + availableModel.name + \" is now available.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\nCheck it out: \" + meteor_1.Meteor.absoluteUrl() + \"\\n\"\r\n                });\r\n            }\r\n        }\r\n    },\r\n    reply: function (availableModelId, rsvp) {\r\n        var _this = this;\r\n        check_1.check(availableModelId, String);\r\n        check_1.check(rsvp, String);\r\n        if (!this.userId) {\r\n            throw new meteor_1.Meteor.Error('403', 'You must be logged in to reply');\r\n        }\r\n        if (['yes', 'no', 'maybe'].indexOf(rsvp) === -1) {\r\n            throw new meteor_1.Meteor.Error('400', 'Invalid RSVP');\r\n        }\r\n        var availableModel = available_collection_1.Available.findOne({ _id: availableModelId });\r\n        if (!availableModel) {\r\n            throw new meteor_1.Meteor.Error('404', 'No such item is available!');\r\n        }\r\n        if (availableModel.owner === this.userId) {\r\n            throw new meteor_1.Meteor.Error('500', 'You are the owner!');\r\n        }\r\n        if (!availableModel.public && (!availableModel.invited || availableModel.invited.indexOf(this.userId) == -1)) {\r\n            throw new meteor_1.Meteor.Error('403', 'No such item available');\r\n        }\r\n        var rsvpIndex = availableModel.rsvps ? availableModel.rsvps.findIndex(function (rsvp) { return rsvp.userId === _this.userId; }) : -1;\r\n        if (rsvpIndex !== -1) {\r\n            if (meteor_1.Meteor.isServer) {\r\n                available_collection_1.Available.update({ _id: availableModelId, 'rsvps.userId': this.userId }, { $set: { 'rsvps.$.response': rsvp } });\r\n            }\r\n            else {\r\n                // minimongo doesn't yet support $ in modifier. as a temporary\r\n                // workaround, make a modifier that uses an index. this is\r\n                // safe on the client since there's only one thread.\r\n                var modifier = { $set: {} };\r\n                modifier.$set['rsvps.' + rsvpIndex + '.response'] = rsvp;\r\n                available_collection_1.Available.update(availableModelId, modifier);\r\n            }\r\n        }\r\n        else {\r\n            // add new rsvp entry\r\n            available_collection_1.Available.update(availableModelId, { $push: { rsvps: { userId: this.userId, response: rsvp } } });\r\n        }\r\n    }\r\n});\r\n//# sourceMappingURL=available.methods.js.map","sourceMap":{"version":3,"file":"available.methods.js","sourceRoot":"","sources":["both/methods/available.methods.ts"],"names":[],"mappings":"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","sourcesContent":["import { Available } from '../collections/available.collection';\nimport { Email } from 'meteor/email';\nimport { check } from 'meteor/check';\nimport { Meteor } from 'meteor/meteor';\n\nfunction getContactEmail(user:Meteor.User):string {\n\tif (user.emails && user.emails.length) {\n\t\treturn user.emails[0].address;\n\t}\n\n\treturn null;\n}\n\nMeteor.methods({\n\tinvite: function (availableModelId:string, userId:string) {\n\t\tcheck(availableModelId, String);\n\t\tcheck(userId, String);\n\n\t\tlet availableModel = Available.collection.findOne(availableModelId);\n\n\t\tif (!availableModel) {\n\t\t\tthrow new Meteor.Error('404', 'No such item available!');\n\t\t}\n\n\t\tif (availableModel.public) {\n\t\t\tthrow new Meteor.Error('403', 'Need Permissions!');\n\t\t}\n\n\t\tif (userId !== availableModel.owner && (availableModel.invited || []).indexOf(userId) == -1) {\n\t\t\tAvailable.collection.update(availableModelId, {$addToSet: { invited: userId }});\n\n\t\t\tlet from = getContactEmail(Meteor.users.findOne(this.userId)),\n\t\t\t\t\tto = getContactEmail(Meteor.users.findOne(userId));\n\n\t\t\tif (Meteor.isServer && to) {\n\t\t\t\tEmail.send({\n\t\t\t\t\tfrom: 'team@canikickit.tv',\n\t\t\t\t\tto: to,\n\t\t\t\t\treplyTo: from || undefined,\n\t\t\t\t\tsubject: 'Available:' + availableModel.name,\n\t\t\t\t\ttext: `Hello, I just wnated you to know ${availableModel.name} is now available.\n\t\t\t\t\t\t\t\t\\n\\nCheck it out: ${Meteor.absoluteUrl()}\\n`\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\treply: function(availableModelId: string, rsvp: string) {\n\t\tcheck(availableModelId, String);\n\t\tcheck(rsvp, String);\n\n\t\tif (!this.userId) {\n\t\t\tthrow new Meteor.Error('403', 'You must be logged in to reply');\n\t\t}\n\n\t\tif (['yes', 'no', 'maybe'].indexOf(rsvp) === -1) {\n\t\t\tthrow new Meteor.Error('400', 'Invalid RSVP');\n\t\t}\n\n\t\tlet availableModel = Available.findOne({ _id: availableModelId });\n\n\t\tif (!availableModel) {\n\t\t\tthrow new Meteor.Error('404', 'No such item is available!');\n\t\t}\n\n\t\tif(availableModel.owner === this.userId) {\n\t\t\tthrow new Meteor.Error('500', 'You are the owner!');\n\t\t}\n\n\t\tif (!availableModel.public && (!availableModel.invited || availableModel.invited.indexOf(this.userId) == -1)) {\n\t\t\tthrow new Meteor.Error('403', 'No such item available');\n\t\t}\n\n\t\tlet rsvpIndex = availableModel.rsvps ? availableModel.rsvps.findIndex((rsvp) => rsvp.userId === this.userId) : -1;\n\n\t\tif (rsvpIndex !== -1) {\n\t\t\tif (Meteor.isServer) {\n\t\t\t\tAvailable.update(\n\t\t\t\t\t{_id: availableModelId, 'rsvps.userId': this.userId },\n\t\t\t\t\t{ $set: { 'rsvps.$.response': rsvp } }\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// minimongo doesn't yet support $ in modifier. as a temporary\n        // workaround, make a modifier that uses an index. this is\n        // safe on the client since there's only one thread.\n        let modifier = { $set: {} };\n        modifier.$set['rsvps.' + rsvpIndex + '.response'] = rsvp;\n\n        Available.update(availableModelId, modifier);\n\t\t\t}\n\t\t} else {\n\t\t\t// add new rsvp entry\n\t\t\tAvailable.update(availableModelId,\n\t\t\t\t{ $push: { rsvps: { userId: this.userId, response: rsvp } }});\n\t\t}\n\t}\n});\n"]},"version":"1","isExternal":true,"dependencies":{"modules":["both/collections/available.collection.ts"],"refFiles":[],"refTypings":[],"mappings":[{"modulePath":"../collections/available.collection","resolvedPath":"both/collections/available.collection","external":false,"resolved":true},{"modulePath":"meteor/email","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"meteor/check","resolvedPath":null,"external":false,"resolved":false},{"modulePath":"meteor/meteor","resolvedPath":null,"external":false,"resolved":false}]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"both/methods/available.methods.ts","message":"Cannot find module 'meteor/email'.","line":2,"column":23},{"code":2307,"fileName":"both/methods/available.methods.ts","message":"Cannot find module 'meteor/check'.","line":3,"column":23},{"code":2307,"fileName":"both/methods/available.methods.ts","message":"Cannot find module 'meteor/meteor'.","line":4,"column":24}]},"hash":"10f2795c4c62950556f24fcba781bc55f38aa289"}